---
title: "Haemdata - Target Markdown"
output: html_document
format:
  html:
    title: "Haemdata - Target Markdown"
    theme: simplex
    self-contained: true
knit: (function(inputFile, encoding) { 
          rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file='index.html') })    
---

# Setup {.tabset}

## In brief

The pipeline is implemented using the {targets} package, which helps to optimize the workflow by caching intermediate outputs, capturing pipeline dependencies, and making it easy to run on the HPC in a reproducible way.

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, warning = FALSE, message = FALSE, comment = "#>")
library(targets)
library(tarchetypes)
tar_unscript()
```

## Globals

Define some global options/functions common to all targets.

```{targets global-options, tar_globals = TRUE}
options(tidyverse.quiet = TRUE)
tar_option_set(
    packages = c("tidyverse", "SummarizedExperiment"), # packages that targets need to run
    error = "abridge", # continue or stop on error
    # format = "qs", # default storage format
    storage = "worker",
    retrieval = "worker"
    # garbage_collection = TRUE,
    # memory = "transient"
)
# Load the R scripts & functions:
for (file in list.files(here::here("preprocessing/scripts"), full.names = TRUE)) source(file)
for (file in list.files(here::here("R"), pattern = "*.R", full.names = TRUE)) source(file)
published_metadata_mmu <- readRDS(here::here("data-raw/metadata_mmu.rds"))
```

## nf-core pipeline versions

```{targets pipeline-versions, tar_globals = TRUE}
rnaseq_release <- "3.7"
smrnaseq_release <- "2.1.0"
```

# Metadata {.tabset}

## In brief

First, consolidate and update metadata as appropriate. For **mmu**, the sample metadata is largely complete. The current implementation adds miRNAseq samples and metadata, and adds a "sample_id" that uniquely identifies each tissue sample, some of which are subject to multiple assays. 

For **hsa** metadata, this target row binds all available metadata in to an ugly and largely incomplete table.

## Mouse metadata

Update mouse metadata with any new samples or corrections

```{targets metadata_mmu_prepub}
tar_target(metadata_mmu_prepub, update_metadata_mmu())
```

## Human metadata 

Consolidate metadata across human samples

```{targets metadata_hsa}
tar_target(
    metadata_hsa, make_metadata_hsa(
        dplyr::full_join(sample_sheet_2022_3, sample_sheet_2022_2) |>
        dplyr::full_join(sample_sheet_2022_4))
    )
```

# Assays {.tabset}

## In brief

The workflows for all assays begin with raw sequencing reads, either fastq files for mRNA and miRNA, or h5ad files for 10x reads.

These files are stored on COH's Isilon storage by the Integrative Genomics Core, and are organized across multiple investigator's Seq folders. The haemdata package version 0.0.0.9008 includes scripts that were used to parse and organize these files, and the code for this process is available on GitHub.

For most samples, fastq (& 10X) Isilon file paths are available in the metadata table from v0.0.0.9008 (2022-11-14).

## mRNA

### Sample sheets

RNAseq libraries were constructed using the KapaHyper with RiboErase kit and run on a Illumina sequencer, as [described](https://doi.org/10.1158/0008-5472.CAN-20-0354).

To assess library quality control metrics and produce unified expression matrices, we use the nf-core/rnaseq pipeline. The following targets prepare sample sheets for the pipeline as described in the documentation <https://nf-co.re/rnaseq/usage#samplesheet-input>.

Samples from `CML.mRNA.2022_pt2` became available after the 2016-2022 combined run and so are run separately and joined in a later step with other samples as *all_mice*. Before the nf-core/rnaseq pipeline is run again AML.scRNAseq.2022 should be added to the "pattern" so they are run with outer samples. 

```{targets sample_sheet_2016_2022}
list(
    tar_target(pattern_2016_2022, "^AML.mRNA.2016$|^AML.mRNA.2018.all_samples$|^AML.mRNA.2020$|
        |^AML.mRNA.2021.RxGroup1$|^AML.mRNA.2021.RxGroup2$|^AML.mRNA.2021.RxGroup2_pt2$|
        |^AML.mRNA.2022.RxGroup3$|^CML.mRNA.2021$|^CML.mRNA.2022$"), 
    
    tar_target(sample_sheet_2016_2022, published_metadata_mmu |>
        dplyr::filter(str_detect(cohort, pattern_2016_2022)) |>
        dplyr::select(library_id, fastq_1, fastq_2, strandedness)),

    tar_target(sample_sheet_CML_3, published_metadata_mmu |>
        dplyr::filter(str_detect(cohort, "^CML.mRNA.2022_pt2$")) |>
        dplyr::select(library_id, fastq_1, fastq_2, strandedness))
)        
```

Two datasets have not been integrated into sample metadata tables: the "validation mice" and human AML data. The mouse samples are from a sequencing validation run and can be considered technical replicates. Human samples have metadata that's inconsistent between experiments. Until we decide on the minimum metadata to collect for human samples, these datasets will remain separate. The following targets locate the fastq files on Isilon and make sample sheets for the nf-core/rnaseq pipeline.

```{targets validation_mmu_and_hsa_aml}
list(
# AML validation samples
    tar_target(sample_sheet_2017_1, parse_metadata_AML.validation.2017()),
    tar_target(sample_sheet_2020_2, parse_metadata_AML.mRNA.novaseq_validation.2020()),
    tar_target(
        sample_sheet_techrep,
        rbind(
            sample_sheet_2017_1,
            sample_sheet_2020_2
        )
    ),
# AML & MDS patients (COH Biobank); MDS from EGAD00001003891; AML patients from PRJEB27973
    tar_target(sample_sheet_2022_2, parse_metadata_AML.mRNA.HSA_FLT3.2022()),
    tar_target(sample_sheet_2022_3, parse_metadata_MDS.rnaseq.EGAD00001003891()),
    tar_target(sample_sheet_2022_4, parse_metadata_AML.PRJEB27973())
)
```


### Run nf-core/rnaseq {.tabset}

Target names and their outputs adhere to the format *species_protocol_cohort_ref-genome_workflow*

*cohort*: {2016_2022, validation, flt3, mds, 2022_1} \
*species*: {mmu\|hsa} \
*protocol*: {mrna\|10x\|mirna} \
*ref-genome*: {GENCODEr40\|GENCODEm28_HLT\|GRCm38_HLT\|GRCh38} \
*workflow*: {qc\|salmon\|seurat}}

Construct the `run_folder` parameter for run_nf_core_rnaseq() as *species_protocol_cohort*. This would be a good candidate to implement tar_map().

```{targets sample_sheets}
list(
    tar_target(mmu_mrna_2016_2022_qc,
        run_nf_core_rnaseq("mmu_mrna_2016_2022", sample_sheet_2016_2022, "GENCODEm28_HLT"),
        format = "file"
    ),
    tar_target(mmu_mrna_techrep_qc,
        run_nf_core_rnaseq("mmu_mrna_techrep", sample_sheet_techrep, "GENCODEm28_HLT"),
        format = "file"
    ),
    tar_target(mmu_mrna_cml3_qc,
        run_nf_core_rnaseq("mmu_mrna_cml3_qc", sample_sheet_CML_3, "GENCODEm28_HLT"),
        format = "file"
    ),
    tar_target(hsa_mrna_flt3_qc,
        run_nf_core_rnaseq("hsa_mrna_flt3", sample_sheet_2022_2, "GENCODEr40"),
        format = "file"
    ),
    tar_target(hsa_mrna_mds_qc,
        run_nf_core_rnaseq("hsa_mrna_mds", sample_sheet_2022_3, "GENCODEr40"),
        format = "file"
    ),
    tar_target(hsa_mrna_kim_qc,
        run_nf_core_rnaseq("hsa_mrna_kim", sample_sheet_2022_4, "GENCODEr40"),
        format = "file"
    )
)
```

### Make SummarisedExperiments

From each nf-core/rnaseq pipeline run, annotate the `salmon/salmon.merged.gene_counts.rds` SummarizedExperiment with sample metadata and QC metrics

#### Human datasets

```{targets hsa_summarised_experiments_1}
tar_target(hsa_mrna_flt3_qc_se_bare, get_rnaseq_se(hsa_mrna_flt3_qc))
```

```{targets hsa_summarised_experiments}
list(
    tar_target(hsa_mrna_flt3_qc_se, annotate_se(hsa_mrna_flt3_qc_se_bare, metadata_hsa, hsa_mrna_flt3_qc)),
    tar_target(hsa_mrna_mds_qc_se, annotate_se(get_rnaseq_se(hsa_mrna_mds_qc), metadata_hsa, hsa_mrna_mds_qc)),
    tar_target(hsa_mrna_kim_qc_se, annotate_se(get_rnaseq_se(hsa_mrna_kim_qc), metadata_hsa, hsa_mrna_kim_qc))
)
```

#### Mouse datasets

```{targets mmu_summarised_experiments}
list(
    tar_target(mmu_mrna_2016_2022_qc_se, annotate_se(
        get_rnaseq_se(mmu_mrna_2016_2022_qc), metadata_mmu_prepub, mmu_mrna_2016_2022_qc
    )),
    tar_target(mmu_mrna_techrep_qc_se, annotate_se(
        get_rnaseq_se(mmu_mrna_techrep_qc), metadata_mmu_prepub, mmu_mrna_techrep_qc
    )),
    tar_target(mmu_mrna_cml3_qc_se, annotate_se(
        get_rnaseq_se(mmu_mrna_cml3_qc), metadata_mmu_prepub, mmu_mrna_cml3_qc
    ))
)
```

### Merge SummarisedExperiments

Merge the late-coming CML samples with all other mice into a single SummarisedExperiment.

```{targets merge_summarised_experiments}
tar_target(mmu_mrna_all_mice_qc_se, merge_mrna_se(mmu_mrna_2016_2022_qc_se, mmu_mrna_cml3_qc_se,
    new_name = "mmu_mrna_all_mice_GENCODEm28_HLT_qc")
)
```

### Quality control

Flag mouse samples that fail the STAR uniquely mapped reads threshold of 5%; any other changes to the metadata table can be made here, prior to publishing the final version.  

```{targets flag_lowly_mapped_mmu_se}
tar_target(metadata_mmu, flag_lowly_mapped_mmu_se(mmu_mrna_all_mice_qc_se, metadata_mmu_prepub))
```

Remove human samples that fail the STAR uniquely mapped reads threshold of 5%

```{targets qc_filter_se}
list(
    tar_target(hsa_mrna_flt3_qc_se_flt, qc_filter_se(hsa_mrna_flt3_qc_se)),
    tar_target(hsa_mrna_mds_qc_se_flt, qc_filter_se(hsa_mrna_mds_qc_se)),
    tar_target(hsa_mrna_kim_qc_se_flt, qc_filter_se(hsa_mrna_kim_qc_se))
)
```

# Pipeline

If you ran all the `{targets}` chunks in non-interactive mode, then your R scripts are set up to run the pipeline.

```{r}
Sys.setenv(SLURM_BIND="/var/run/munge:/run/munge,/opt/apollo-setup/slurm-singularity/etc:/etc/slurm,/var/spool/slurmd")
Sys.setenv(SINGULARITY_BIND="/labs,/opt/singularity,/opt/singularity-images/rbioc,${SLURM_BIND}")

system("srun -c 4 --mem 40G --time 8:00:00 \
    /opt/singularity/3.7.0/bin/singularity exec \
    --env R_LIBS_SITE=/opt/singularity-images/rbioc/rlibs/bioc-3.16 \
    /opt/singularity-images/rbioc/vscode-rbioc_3.16.sif \
    Rscript -e '.libPaths()'", intern = TRUE)

```

# Output

You can retrieve results from the `_targets/` data store using `tar_read()` or `tar_load()`.

```{r, message = FALSE}
# library(SummarisedExperiment)
# tar_read(fit)
```

The `targets` dependency graph helps in understanding the steps of the pipeline at a high level.

```{r}
#tar_visnetwork(targets_only = TRUE)
```

At this point, you can go back and run `{targets}` chunks in interactive mode without interfering with the code or data of the non-interactive pipeline.
