---
title: "Preprocessing pipeline"
theme: simplex
embed-resources: true
standalone: true
---

<p style="font-size: small">

Source: [preprocessing/\_targets.qmd](https://github.com/drejom/haemdata/blob/main/preprocessing/_targets.qmd)

</p>

# Setup

::: panel-tabset
## In brief

Haemdata is an R package in two-parts: a targets pipeline that preprocesses raw sequencing reads and functions to access processed data.

::: {.callout-note appearance="simple"}

The [{`targets`}](https://books.ropensci.org/targets/) package streamlines data workflows and promotes reproducibility. It skips redundant tasks and abstracts files as R objects to ensure efficient, painless, and trustworthy results.

:::

## Load libraries & options

Set options and load libraries required to run the pipeline.

```{r setup}
library(targets)
library(tarchetypes)
tar_unscript()

knitr::opts_chunk$set(
    collapse = TRUE,
    warning = FALSE,
    message = FALSE,
    comment = "#>")
```

## Pipeline globals

Define global options, functions & variables common to all targets.

### Global options

```{targets global-options, tar_globals = TRUE}
options(tidyverse.quiet = TRUE)

tar_option_set(
    packages = c("tidyverse", "SummarizedExperiment", "haemdata", "tarchetypes"),
    error = "abridge", # continue with remaining targets on error
    storage = "worker",
    retrieval = "worker"
)

# Load the R scripts & functions:
for (file in list.files(here::here("preprocessing/scripts"), full.names = TRUE)) source(file)

# for (file in list.files(here::here("R"), pattern = "*.R", full.names = TRUE)) source(file)
```

### nf-core pipeline versions

```{targets pipeline-variables, tar_globals = TRUE}
rnaseq_release <- "3.7"
smrnaseq_release <- "2.1.0"
scrnaseq_release <- "2.1.0"
```

### Cohort selectors
```{targets cohort-selectors, tar_globals = TRUE}
all_mice <- "^AML.mRNA.2016$|^AML.mRNA.2018.all_samples$|^AML.mRNA.2020$|
        |^AML.mRNA.2021.RxGroup1$|^AML.mRNA.2021.RxGroup2$|^AML.mRNA.2021.RxGroup2_pt2$|
        |^AML.mRNA.2022.RxGroup3$|^CML.mRNA.2021$|^CML.mRNA.2022$|^CML.mRNA.2022_pt2$"

aml_mice <- "^AML.mRNA.2016$|^AML.mRNA.2018.all_samples$|^AML.mRNA.2020$|
        |^AML.mRNA.2021.RxGroup1$|^AML.mRNA.2021.RxGroup2$|^AML.mRNA.2021.RxGroup2_pt2$|
        |^AML.mRNA.2022.RxGroup3$"

chemo_mice <- "^AML.mRNA.2020$"

treatment_mice <- "^AML.mRNA.2021.RxGroup1$|^AML.mRNA.2021.RxGroup2$|
        |^AML.mRNA.2021.RxGroup2_pt2$|^AML.mRNA.2022.RxGroup3$"

cml_mice <- "^CML.mRNA.2021$|^CML.mRNA.2022$|^CML.mRNA.2022_pt2$"
```
:::

# Metadata

::: panel-tabset
## In brief

Haemdata includes comprehensive metadata about samples, such as collection date, assay, sequencing libraries, sex, age, treatment information, and a range of other biological and technical metrics.

The code to collate it has been through multiple iterations, is complex and ugly and undoubtedly some mistakes will have made it through. Errors or omissions can be reported on [GitHub](https://github.com/drejom/haemdata/issues).

```{targets published_metadata_mmu}
tar_target(
    published_metadata_mmu,
    readRDS(here::here("data-raw/metadata_mmu.rds")))
```

## Mouse metadata

For **mmu**, the sample metadata is largely complete. These data were collated from multiple sequencing run sheets, directly from sequencing folders, emails, and so forth.

The current implementation of `update_metadata_mmu()` adds metadata for treatment mice, miRNAseq samples and metadata, and adds a "sample_id" that uniquely identifies each tissue sample, some of which are subject to multiple assays.

```{targets metadata_mmu_prepub}
tar_target(metadata_mmu_prepub, update_metadata_mmu())
```

## Human metadata

For **hsa** metadata, `make_metadata_hsa()` row binds all available metadata in to an ugly and largely incomplete table.

The current implementation simply consolidates metadata across sample sheets.

```{targets metadata_hsa}
tar_target(
    metadata_hsa,
    make_metadata_hsa(
        dplyr::full_join(sample_sheet_2022_3, sample_sheet_2022_2) |>
        dplyr::full_join(sample_sheet_2022_4))
    )
```
:::

# Assays

::: panel-tabset

## In brief

The workflows for all assays begin with raw sequencing reads, either fastq files or h5ad files for 10X Cellplex libraries.

Raw data are stored on COH's Isilon storage by the Integrative Genomics Core, organized across multiple investigator's `Seq` folders. Since v0.0.0.9008 (2022-11-14), file paths are stored in the metadata table.

Functions in this section format sample sheets for nf-core pipelines, submit pipelines to the Apollo cluster, look for completed runs and extract processed results. For 10X data, functions read in Cellranger output to Seurat objects, apply cell QC filters, perform integration, clustering, UMAP dimension reduction, & annotation of cell cycles and cell types. 

## mRNA

### Sample sheets

To assess library quality control metrics and produce unified expression matrices, we use the nf-core/rnaseq pipeline. The following targets prepare sample sheets as described in the [pipeline documentation](https://nf-co.re/rnaseq/usage#samplesheet-input).

Samples from `CML.mRNA.2022_pt2` became available after the 2016-2022 combined run and so are run separately and joined in a later step with other samples as *all_mice*.

```{targets sample_sheet_2016_2022}
list(
    tar_target(sample_sheet_2016_2022,
        published_metadata_mmu |>
        dplyr::filter(str_detect(cohort, all_mice)) |>
        dplyr::select(library_id, fastq_1, fastq_2, strandedness)),
    tar_target(sample_sheet_CML_3,
        published_metadata_mmu |>
        dplyr::filter(str_detect(cohort, "^CML.mRNA.2022_pt2$")) |>
        dplyr::select(library_id, fastq_1, fastq_2, strandedness))
)        
```

Two datasets have not been integrated into sample metadata tables: 

- "Validation mice" from a sequencing validation run and can be considered technical replicates.
- Human AML samples have metadata that's inconsistent between experiments. Until we decide on the minimum metadata to collect for human samples, these datasets will remain separate. 

The following targets locate the fastq files on Isilon and make sample sheets for the nf-core/rnaseq pipeline.

```{targets mrna_validation_mmu_and_hsa_aml}
list(
# AML validation samples
    tar_target(sample_sheet_2017_1, parse_metadata_AML.validation.2017()),
    tar_target(sample_sheet_2020_2, parse_metadata_AML.mRNA.novaseq_validation.2020()),
    tar_target(
        sample_sheet_techrep,
        rbind(
            sample_sheet_2017_1,
            sample_sheet_2020_2
        )
    ),
# AML & MDS patients (COH Biobank); MDS from EGAD00001003891; AML patients from PRJEB27973
    tar_target(sample_sheet_2022_2, parse_metadata_AML.mRNA.HSA_FLT3.2022()),
    tar_target(sample_sheet_2022_3, parse_metadata_MDS.rnaseq.EGAD00001003891()),
    tar_target(sample_sheet_2022_4, parse_metadata_AML.PRJEB27973())
)
```

### Run nf-core/rnaseq

Target names and their outputs adhere to the format *species_protocol_cohort_ref-genome_workflow*

|  |  |
|---|---|
| **_cohort_** | 2016_2022, validation, flt3, mds, 2022_1 |
| **_species_** | mmu, hsa |
| **_protocol_** | mrna, 10x, mirna |
| **_ref-genome_** | GENCODEr40, GENCODEm28_HLT, GRCm38_HLT, GRCh38 |
| **_workflow_** | qc, salmon, seurat |

Construct the `run_folder` parameter for `run_nf_core_rnaseq()` using the tokens *species_protocol_cohort*.

::: callout-tip
## Code suggestion

This would be a good spot to implement `tar_map()`.
:::

```{targets mrna_sample_sheets}
list(
    tar_target(mmu_mrna_2016_2022_qc,
        run_nf_core_rnaseq("mmu_mrna_2016_2022", sample_sheet_2016_2022, "GENCODEm28_HLT"),
        format = "file"
    ),
    tar_target(mmu_mrna_techrep_qc,
        run_nf_core_rnaseq("mmu_mrna_techrep", sample_sheet_techrep, "GENCODEm28_HLT"),
        format = "file"
    ),
    tar_target(mmu_mrna_cml3_qc,
        run_nf_core_rnaseq("mmu_mrna_cml3_qc", sample_sheet_CML_3, "GENCODEm28_HLT"),
        format = "file"
    ),
    tar_target(hsa_mrna_flt3_qc,
        run_nf_core_rnaseq("hsa_mrna_flt3", sample_sheet_2022_2, "GENCODEr40"),
        format = "file"
    ),
    tar_target(hsa_mrna_mds_qc,
        run_nf_core_rnaseq("hsa_mrna_mds", sample_sheet_2022_3, "GENCODEr40"),
        format = "file"
    ),
    tar_target(hsa_mrna_kim_qc,
        run_nf_core_rnaseq("hsa_mrna_kim", sample_sheet_2022_4, "GENCODEr40"),
        format = "file"
    )
)
```

### Make SummarisedExperiments

From each nf-core/rnaseq pipeline run, annotate the `salmon/salmon.merged.gene_counts.rds` SummarizedExperiment with sample metadata and QC metrics

#### Mouse datasets

```{targets mrna_mmu_summarised_experiments}
list(
    tar_target(mmu_mrna_2016_2022_qc_se,
        annotate_se(
            get_rnaseq_se(mmu_mrna_2016_2022_qc),
            metadata_mmu_prepub,
            mmu_mrna_2016_2022_qc
    )),
    tar_target(
        mmu_mrna_techrep_qc_se,
        annotate_se(
            get_rnaseq_se(mmu_mrna_techrep_qc),
            metadata_mmu_prepub,
            mmu_mrna_techrep_qc
    )),
    tar_target(
        mmu_mrna_cml3_qc_se,
        annotate_se(
            get_rnaseq_se(mmu_mrna_cml3_qc),
            metadata_mmu_prepub,
            mmu_mrna_cml3_qc
    ))
)
```

#### Human datasets

```{targets mrna_hsa_summarised_experiments}
list(
    tar_target(hsa_mrna_flt3_qc_se, annotate_se(get_rnaseq_se(hsa_mrna_flt3_qc), metadata_hsa, hsa_mrna_flt3_qc)),
    tar_target(hsa_mrna_mds_qc_se, annotate_se(get_rnaseq_se(hsa_mrna_mds_qc), metadata_hsa, hsa_mrna_mds_qc)),
    tar_target(hsa_mrna_kim_qc_se, annotate_se(get_rnaseq_se(hsa_mrna_kim_qc), metadata_hsa, hsa_mrna_kim_qc))
)
```

### Merge SummarisedExperiments

Merge the late-coming CML samples with all other mice into a single SummarisedExperiment.

```{targets mrna_merge_summarised_experiments}
tar_target(
    mmu_mrna_all_mice_qc_se, 
    merge_mrna_se(
        mmu_mrna_2016_2022_qc_se,
        mmu_mrna_cml3_qc_se,
        new_name = "mmu_mrna_all_mice_GENCODEm28_HLT_qc")
)
```

### Quality control

Flag mouse samples that fail the STAR uniquely mapped reads threshold of 5%; any other changes to the metadata table can be made here, prior to publishing the final version.

```{targets mrna_flag_lowly_mapped_mmu_se}
tar_target(
    metadata_mmu,
    flag_lowly_mapped_mmu_se(mmu_mrna_all_mice_qc_se, metadata_mmu_prepub))
```

Remove human samples that fail the STAR uniquely mapped reads threshold of 5%

```{targets mrna_qc_filter_se}
list(
    tar_target(hsa_mrna_flt3_qc_se_flt, qc_filter_se(hsa_mrna_flt3_qc_se)),
    tar_target(hsa_mrna_mds_qc_se_flt, qc_filter_se(hsa_mrna_mds_qc_se)),
    tar_target(hsa_mrna_kim_qc_se_flt, qc_filter_se(hsa_mrna_kim_qc_se))
)
```

## miRNA

### Sample sheets

The Integrative Genomics Core has implemented a custom "home brew" miRNAseq protocol that uses a modified Illumina adapter and requires additional clipping, accomplished with `cutadapt`, eg:

```{sh eval=FALSE}
cutadapt -a TCTGGAATTCTCGGGTGCCAAGGAACTCC -m 16 -u 3 -o OUT.cutadapt.fq.gz IN.fq.gz
```

Some libraries were delivered by the Core with the adapter already removed and 3bp clipped from the 3' end prior to processing.

Somewhere along the line, the original, unedited fastqs were lost from the Isilon storage and now only the trimmed fastqs are available, so two independent runs are required.

#### Pre-trimmed

```{targets mirna-sample-sheets_pretrimmed}
tar_target(miRNA_sample_sheet_pretrimmed,
    published_metadata_mmu |>
        dplyr::filter(stringr::str_detect(assay, "miRNA")) |>
        dplyr::filter(stringr::str_detect(fastq_1, "cutadapt")) |>
        dplyr::select(sample_id, library_id, fastq_1)
        )
```

#### Untrimmed

```{targets mirna-sample-sheets_untrimmed}
tar_target(
    miRNA_sample_sheet_untrimmed,
    published_metadata_mmu |>
        dplyr::filter(stringr::str_detect(assay, "miRNA")) |>
        dplyr::filter(stringr::str_detect(fastq_1, "cutadapt", negate = TRUE)) |>
        dplyr::select(sample_id, library_id, fastq_1)
    )
```

For untrimmed libraries, we use a function that loads the Apollo `cutadapt` module and spawns a job for each fastq file on the cluster. The trimmed files are cached in {nf_core_cache} and a sample sheet for the nf-core/smrnaseq pipeline is returned using the cached, trimmed and compressed fastqs.

```{targets run_cutadapt_smrna}
tar_target(miRNA_sample_sheet_trimmed, run_cutadapt_smrna(miRNA_sample_sheet_untrimmed))
```

### nf-core/smRNAseq pipeline

The nf-core/smrnaseq pipeline includes several tools that provide a comprehensive analysis of microRNAseq data including [mirTrace](https://github.com/friedlanderlab/mirtrace) for QC and contamination, [mirTop]() for count matrices of miRNA and isomiRs, and [miRDeep2](https://www.mdc-berlin.de/content/mirdeep2-documentation) for quantification and discovery of novel miRNAs.

```{targets nf-core-smrnaseq, eval=TRUE}
list(
    tar_target(mmu_mirna_pretrimmed_multiqc,
        run_nfcore_smrnaseq("mmu_mirna_pretrimmed", miRNA_sample_sheet_pretrimmed),
        format = "file"
        ),
    tar_target(mmu_mirna_trimmed_multiqc,
        run_nfcore_smrnaseq("mmu_mirna_untrimmed", miRNA_sample_sheet_trimmed),
        format = "file"
    )
)
```

::: callout-tip
## Code suggestion

In a future release, all samples could be run together after preprocessing. 
:::

### Bowtie counts

Extract [mature miRNA normalised CPM](https://nf-co.re/smrnaseq/2.1.0/output#edger) and merge the matrices across runs.

```{targets nf-core-smrnaseq-cpm, eval=TRUE}
list(
    tar_target(mmu_mirna_pretrimmed_cpm, nfcore_smrna_cpm(mmu_mirna_pretrimmed_multiqc)),
    tar_target(mmu_mirna_trimmed_cpm, nfcore_smrna_cpm(mmu_mirna_trimmed_multiqc)),
    tar_target(mmu_mirna_bowtie_cpm, merge(mmu_mirna_pretrimmed_cpm, mmu_mirna_trimmed_cpm, by = 'row.names', all = TRUE))
)
```

### mirTop counts

[mirtop](https://nf-co.re/smrnaseq/2.1.0/output#mirtop) parses bowtie BAMs producing a mirgff3 file with information about miRNAs and isomiRs.

The nfcore/smrnaseq pipeline includes a [script](https://github.com/nf-core/smrnaseq/blob/master/bin/collapse_mirtop.r) to collapse mirtop output to a matrix, which is extracted and combined across runs:

```{targets nf-core-smrnaseq-mirtop-counts, eval=TRUE}
list(
    tar_target(mmu_mirna_pretrimmed_mirtop_counts, nfcore_mirtop_counts(mmu_mirna_pretrimmed_multiqc)),
    tar_target(mmu_mirna_trimmed_mirtop_counts, nfcore_mirtop_counts(mmu_mirna_trimmed_multiqc)),
    tar_target(mmu_mirna_mirtop_counts, 
        dplyr::left_join(
            mmu_mirna_pretrimmed_mirtop_counts, mmu_mirna_trimmed_mirtop_counts, by = "miRNA"))
)
```

### mirTop isomiRs

- mirTop for isomiRs: [Desvignes et al 2020](https://academic.oup.com/bioinformatics/article/36/3/698/5556118) 
- Nice isomiR review: [Tomasello et al 2021](https://www.frontiersin.org/articles/10.3389/fcell.2021.668648/full)

```{targets nf-core-smrnaseq-mirtop-isomir, eval=FALSE}
list(
    tar_target(mmu_mirna_pretrimmed_mirtop_isomir, nfcore_mirtop_isomir(mmu_mirna_pretrimmed_multiqc)),
    tar_target(mmu_mirna_trimmed_mirtop_isomir, nfcore_mirtop_isomir(mmu_mirna_trimmed_multiqc)),
    tar_target(mmu_mirna_mirtop_isomir, left_join(mmu_mirna_pretrimmed_mirtop_isomir, mmu_mirna_trimmed_mirtop_isomir, by = c("seq", "mir", "mism", "add", "t5", "t3"))),
    tar_target(mmu_mirna_isomir, make_isomir(mmu_mirna_mirtop_isomir, metadata_mmu)
    #,resources = apollo_medium
    )
)
```

::: {.callout-important}
This fails to combine the runs; not published for now.
:::

### mirTrace & samtools metrics

Extract mirTrace and samtools QC metrics

```{targets nf-core-smrnaseq-qc-metrics, eval=TRUE}
list(
    tar_target(mmu_mirna_pretrimmed_qc, nfcore_smrna_qc(mmu_mirna_pretrimmed_multiqc)),
    tar_target(mmu_mirna_trimmed_qc, nfcore_smrna_qc(mmu_mirna_trimmed_multiqc)),
    tar_target(mmu_mirna_qc, rbind(mmu_mirna_pretrimmed_qc, mmu_mirna_trimmed_qc))
)
```

## 10X 

::: {.callout-tip}
## Code suggestion
As currently written, the 10X workflow chains together some resource-intensive functions that could be implemented more efficiently. For instance, we could store only the new cell metadata that results from each function/step, rather than passing a new Seurat object from one step to the next. 
:::

### Load data

#### Multiplexed samples

The *2022 AML scRNAseq cohort* was sequenced using the 10X [CellPlex](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/algorithms/cellplex) cell multiplexing protocol. 

The [`make_seurat_objects()`](http://cgt.coh.org/haemdata/reference/make_seurat_objects.html) function builds Seurat objects and adds cell metadata columns indicating the percent expression of mitochondrial, ribosomal, haemoglobin, platelet, _Xist_ & chrY genes, and the transgene _MYH11_.

```{targets seurat_import_objects_2022, eval=TRUE}
tar_target(
    mmu_10x_2022_1_GENCODEm28_HLT,
    seurat_import_objects("^AML.scRNAseq.2022$"),
    resources = apollo_medium
    )
```

#### Single sample libraries

10X libraries are typically prepared for a single sample and sequenced, as for the *CML miR-142 KO cohort* from the Zhang/Marcucci lab (T-cell scRNAseq).  The Cellranger protocol is essentially the same for Cellplex libraries, without the demultiplexing steps. 

Metadata for these samples is forthcoming (2023-1-27), so for now, we make a sample sheet by scraping file paths. 

```{targets cml_mir142_ko_sample_sheet, eval=TRUE}
tar_target(
    cml_mir142_ko_sample_sheet,
    parse_cml_mir142_ko()
    )
```

An nf-core/scrnaseq pipeline allows running Cellranger with single-sample libraries, but does not support Cellplex libraries at this stage. Nor does it permit spaces in file paths, so we first link fastq files to the {nf_core_cache}:

```{targets link_fastqs_mir412, eval=TRUE}
tar_target(cml_mir142_ko_sample_sheet_cache, symlink_fastqs("mmu_10X_mir142_ko/fastq", cml_mir142_ko_sample_sheet))
```

```{targets run_nfcore_scrnaseq, eval=TRUE}
tar_target(
    mmu_10x_mir142ko_GENCODEm28_HLT_qc,
    run_nfcore_scrnaseq("mmu_10X_mir142_ko", cml_mir142_ko_sample_sheet_cache)
    )
```

### QC filter 

See [`haemdata::seurat_perform_cell_qc()`](http://cgt.coh.org/haemdata/reference/seurat_perform_cell_qc.html)

Consider including:
- [EmptyDrops](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1662-y)
- [SoupX](https://github.com/constantAmateur/SoupX)
- Others on [GitHub](https://github.com/drejom/haemdata/issues/7)

```{targets seurat_perform_cell_qc, eval=TRUE}
tar_target(
    mmu_10x_2022_1_GENCODEm28_HLT_qc, 
    seurat_perform_cell_qc(mmu_10x_2022_1_GENCODEm28_HLT),
    resources = apollo_bigmem
    )
```

### Integrate samples with SCTransform

See [`haemdata::seurat_sctransform()`](http://cgt.coh.org/haemdata/reference/seurat_sctransform.html)

```{targets seurat_sctransform, eval=TRUE}
    tar_target(
        mmu_10x_2022_1_GENCODEm28_HLT_sct,
        seurat_sctransform(mmu_10x_2022_1_GENCODEm28_HLT_qc),
        resources = apollo_bigmem
    )
```

### Annotate clusters & UMAP

See [`haemdata::seurat_annotate_clusters_and_umap()`](http://cgt.coh.org/haemdata/reference/seurat_annotate_umap_and_clusters.html)

```{targets seurat_annotate_clusters_and_umap, eval=TRUE}
tar_target(
    mmu_10x_2022_1_GENCODEm28_HLT_sct_clust,
    seurat_annotate_clusters_and_umap(mmu_10x_2022_1_GENCODEm28_HLT_sct),
    resources = apollo_large)
```

### Annotate cell cycle 

See [`haemdata::seurat_annotate_cell_cycle()`](http://cgt.coh.org/haemdata/reference/seurat_annotate_cell_cycle.html)

```{targets seurat_annotate_cell_cycle, eval=TRUE}
tar_target(
    mmu_10x_2022_1_GENCODEm28_HLT_sct_clust_cc,
    seurat_annotate_cell_cycle(mmu_10x_2022_1_GENCODEm28_HLT_sct_clust),
    resources = apollo_large
    )
```

### Annotate cell type 

See [`haemdata::seurat_annotate_cell_type()`](http://cgt.coh.org/haemdata/reference/seurat_annotate_cell_cycle.html)

```{targets seurat_annotate_cell_type, eval=TRUE}
tar_target(
    mmu_10x_2022_1_GENCODEm28_HLT_sct_clust_cc_ct,
    seurat_annotate_cell_type(mmu_10x_2022_1_GENCODEm28_HLT_sct_clust_cc),
    resources = apollo_large
    )
```

:::

# Publish pins

::: panel-tabset

## Metadata pins

```{targets publish_metadata_pins, eval=TRUE}
list(
    tarchetypes::tar_change(
        metadata_mmu_pins,
        publish_metadata(metadata_mmu),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    ),
    tarchetypes::tar_change(
        metadata_hsa_pins,
        publish_metadata(metadata_hsa),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    )
)
```

## mRNA pins

```{targets publish_mrna_pins, eval=TRUE}
list(
    tarchetypes::tar_change(
        mmu_mrna_all_mice_GENCODEm28_pins, publish_se(mmu_mrna_all_mice_qc_se),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    ),
    tarchetypes::tar_change(
        mmu_mrna_techrep_GENCODEm28_pins, publish_se(mmu_mrna_techrep_qc_se),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    ),
    tarchetypes::tar_change(
        hsa_mrna_flt3_GENCODEm28_pins, publish_se(hsa_mrna_flt3_qc_se_flt),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    ),
    tarchetypes::tar_change(
        hsa_mrna_mds_GENCODEm28_pins, publish_se(hsa_mrna_mds_qc_se_flt),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    ),
    tarchetypes::tar_change(
        hsa_mrna_kim_GENCODEm28_pins, publish_se(hsa_mrna_kim_qc_se_flt),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    )
)
```

## miRNA pins

```{targets publish_mirna_pins, eval=TRUE}
list( 
    tarchetypes::tar_change(
        mmu_mirna_all_mice_mirtop_counts_pins,
        publish_mirtop_counts(mmu_mirna_mirtop_counts),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    ),
    tarchetypes::tar_change(
        mmu_mirna_all_mice_bowtie_cpm_pins,
        publish_bowtie_cpm(mmu_mirna_bowtie_cpm),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    ),
    tarchetypes::tar_change(
        mmu_mirna_all_mice_mirna_qc_pins,
        publish_mirna_qc(mmu_mirna_qc),
        haemdata::haemdata_env$pin_board[["path"]],
        deployment = "main"
    )
)
```

## 10X pins 

```{targets publish_seurat, eval=TRUE}
tarchetypes::tar_change(
    mmu_10x_2022_1_GENCODEm28_HLT_pins,
    publish_seurat(mmu_10x_2022_1_GENCODEm28_HLT_sct_clust_cc_ct),
    change = haemdata::haemdata_env$pin_board[["path"]],
    resources = apollo_small,
    deployment = "main"
    ) 
```

## Collect latest pin versions

```{targets collect_pin_versions, eval=TRUE}
tar_target(
    latest_published_data,
    haemdata::write_data("published_pins",
    rbind(
    # 10X single cell RNA-seq
        mmu_10x_2022_1_GENCODEm28_HLT_pins,
    # metadata
        metadata_mmu_pins,
        metadata_hsa_pins,
    # micro RNAseq
        mmu_mirna_all_mice_mirtop_counts_pins,
        mmu_mirna_all_mice_bowtie_cpm_pins,
        mmu_mirna_all_mice_mirna_qc_pins,
        
    # bulk RNAseq
        mmu_mrna_all_mice_GENCODEm28_pins,
        mmu_mrna_techrep_GENCODEm28_pins,
        hsa_mrna_flt3_GENCODEm28_pins,
        hsa_mrna_mds_GENCODEm28_pins,
        hsa_mrna_kim_GENCODEm28_pins
    )), deployment = "main", format = "file"
)
```

::: 

# Build package

```{targets build_package, eval=TRUE}
tar_target(
    built_package,
    build_package(latest_published_data),
    resources = apollo_shortmem)
```

# Targets pipeline

Having defined the pipeline targets above, R scripts are run using `tar_make_future()`. This distributes individual targets across the HPC Cluster in parallel, accounting for interdependencies.

```{r, eval = FALSE}
system(
  glue::glue(
    "srun -J run_haemdata --time 48:00 /opt/singularity/3.7.0/bin/singularity exec \\
        --env R_LIBS_SITE=/opt/singularity-images/rbioc/rlibs/bioc-3.16 \\
        -B /labs,/opt/singularity,/opt/singularity-images \\
        --pwd {getwd()} \\
        /opt/singularity-images/rbioc/vscode-rbioc_3.16.sif Rscript -e 'targets::tar_make_future\\(\\)'"
  )
)
```

The dependency graph illustrates the steps of the pipeline. It's interactive and you can zoom/pan to explore the `targets`.

```{r}
tar_visnetwork(targets_only = TRUE)
```

At this point, you can go back and run `{targets}` chunks in interactive mode without interfering with the code or data of the non-interactive pipeline.
